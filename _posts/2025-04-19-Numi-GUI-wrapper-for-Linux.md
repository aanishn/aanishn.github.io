---
layout: post
title: Numi GUI wrapper for Linux
date: '2025-04-19'
author: "aanishn"
tags:
- Numi, python, PySimpleGUI, calculator, claude 
---

GUI wrapper for numi-cli on Linux. Code generated by Claude with minor edits for fixing issues.

```python
#!~/miniconda3/envs/pysimplegui/bin/python
# -*- coding: utf-8 -*-

import PySimpleGUI as sg
import subprocess
import re
import os

# Set theme to match Numi's clean appearance
sg.theme('Default1')  # Light theme similar to Numi

def run_numi_command(expression):
    """Run the numi-cli command with the given expression"""
    try:
        if not expression.strip() or expression.strip().startswith('#'):
            return ""  # No result for empty lines or comments
        result = subprocess.check_output(['~/appsroot/numi-cli', expression],
                                         stderr=subprocess.STDOUT,
                                         text=True)
        return result.strip()
    except subprocess.CalledProcessError as e:
        return f"Error: {e.output.strip()}"
    except Exception as e:
        return f"Error: {str(e)}"

def save_history(expressions):
    """Save expressions to a file"""
    with open(os.path.expanduser("~/.numi_history"), "w") as f:
        for expr in expressions:
            f.write(f"{expr}\n")

def load_history():
    """Load expressions from a file"""
    history_file = os.path.expanduser("~/.numi_history")
    if os.path.exists(history_file):
        try:
            with open(history_file, "r") as f:
                return [line.strip() for line in f]
        except Exception:
            return []
    return []

class NumiEditor:
    def __init__(self):
        # Start with a single empty expression if no history
        history = load_history()
        self.expressions = history if history else [""]
        self.results = []
        self.current_line = 0
        self.window = None

    def create_window(self):
        # Calculate initial results
        self.calculate_all_results()

        # Create custom text element for the editor
        layout = [
            [sg.Text("Numi Calculator", font=("Helvetica", 16), pad=(0, 10))],
            [sg.Multiline(
                key='-EDITOR-',
                size=(60, 20),
                font=('Courier', 12),
                background_color='#F8F8F8',  # Light background similar to window
                text_color='#333333',
                border_width=0,
                autoscroll=True,
                focus=True,
                enable_events=True,
                default_text=self.format_display()
            )],
            [sg.StatusBar("Ready", key='-STATUS-')]
        ]

        # Create the window
        self.window = sg.Window(
            'Numi GUI',
            layout,
            return_keyboard_events=True,
            finalize=True,
            margins=(10, 10),
            element_padding=(0, 0)
        )

        # Bind special events
        self.window['-EDITOR-'].bind('<Return>', '_Enter')

    def calculate_all_results(self):
        """Calculate results for all expressions"""
        self.results = []
        for expr in self.expressions:
            result = run_numi_command(expr)
            self.results.append(result)

    def format_display(self):
        """Format the display text with expressions and results"""
        lines = []
        max_expr_length = max([len(expr) for expr in self.expressions] + [20])

        for i, expr in enumerate(self.expressions):
            result = self.results[i] if i < len(self.results) else ""

            if not expr.strip():
                lines.append("")  # Empty line
            elif expr.strip().startswith('#'):
                # Comment line
                lines.append(f"{expr}")
            elif result:
                # Expression with result
                padding = ' ' * (max_expr_length - len(expr) + 5)
                lines.append(f"{expr}{padding}= {result}")
            else:
                # Expression without result yet
                lines.append(expr)

        return '\n'.join(lines)

    def get_pure_expressions(self):
        """Extract clean expressions from the editor content"""
        content = self.window['-EDITOR-'].get()
        lines = content.split('\n')
        pure_expressions = []

        for line in lines:
            # Skip empty lines
            if not line.strip():
                pure_expressions.append("")
                continue

            # For comments, keep the whole line
            if line.strip().startswith('#'):
                pure_expressions.append(line)
                continue

            # For expressions, take only the part before "="
            if '=' in line:
                # Don't split variable assignments like x = 5
                if re.match(r'^[a-zA-Z][a-zA-Z0-9_]* ?=', line):
                    pure_expressions.append(line)
                else:
                    # Expression with result, strip the result part
                    expr = line.split('=')[0].rstrip()
                    pure_expressions.append(expr)
            else:
                # Regular expression without result
                pure_expressions.append(line)

        return pure_expressions

    def get_current_cursor_line(self):
        """Get the current line where the cursor is"""
        try:
            # Try to get cursor position from tkinter widget
            cursor_pos = self.window['-EDITOR-'].Widget.index('insert')
            line_num = int(cursor_pos.split('.')[0]) - 1  # tkinter lines are 1-indexed
            return line_num
        except:
            # Fallback: estimate based on content length
            content = self.window['-EDITOR-'].get()
            return content.count('\n')

    def handle_return_key(self):
        """Handle when the user presses Enter"""
        # Get clean expressions without results
        self.expressions = self.get_pure_expressions()

        # Get current cursor line
        current_line = self.get_current_cursor_line()

        # Calculate all results
        self.calculate_all_results()

        # Ensure we have a next line
        if current_line >= len(self.expressions) - 1:
            self.expressions.append("")
            self.results.append("")

        # Format display with updated content
        formatted_display = self.format_display()

        # Update the editor
        self.window['-EDITOR-'].update(value=formatted_display)

        # Try to position cursor at the next line
        next_line = current_line + 1
        try:
            # Move cursor to beginning of next line
            self.window['-EDITOR-'].Widget.mark_set('insert', f"{next_line + 1}.0")
            self.window['-EDITOR-'].Widget.see('insert')  # Ensure visible
        except Exception as e:
            print(f"Error setting cursor: {e}")

        # Save history
        save_history(self.expressions)

        # Update status
        self.window['-STATUS-'].update(f"Calculated line {current_line + 1}")

    def run(self):
        """Run the application"""
        self.create_window()

        # Event loop
        while True:
            event, values = self.window.read()

            if event == sg.WIN_CLOSED:
                save_history(self.expressions)
                break

            elif event == '-EDITOR-_Enter':
                self.handle_return_key()

            elif event == '-EDITOR-':
                # When content changes, update expressions but keep results
                new_expressions = self.get_pure_expressions()

                if new_expressions != self.expressions:
                    self.expressions = new_expressions

                    # Ensure we have results for all expressions
                    while len(self.results) < len(self.expressions):
                        self.results.append("")

if __name__ == '__main__':
    editor = NumiEditor()
    editor.run()
```
